<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Morphing Particles (Three.js)</title>
<style>
  body { margin:0; overflow:hidden; background:#0e0e12; }
  canvas { display:block; }
</style>
</head>
<body>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.155.0/build/three.module.js";
import { gsap } from "https://cdn.jsdelivr.net/npm/gsap@3.12.2/index.js";

/* ================= CONFIG ================= */

const textures = [
  "https://threejs.org/examples/textures/sprites/disc.png",
  "https://threejs.org/examples/textures/sprites/snowflake1.png"
];

const density = 140;
const particlesScale = 1.0;
const cameraZoom = 3.5;

/* ================= CORE ================= */

let scene = new THREE.Scene();
scene.background = new THREE.Color(0x12131a);

let camera = new THREE.PerspectiveCamera(40, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = cameraZoom;

let renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ================= POINT DISTRIBUTION ================= */

function generateBasePoints(count){
  let pts = [];
  let size = Math.sqrt(count);
  for(let x=0;x<size;x++){
    for(let y=0;y<size;y++){
      pts.push(
        (x/size - 0.5) * 2,
        (y/size - 0.5) * 2,
        0
      );
    }
  }
  return new Float32Array(pts);
}

const COUNT = density * density;
const basePositions = generateBasePoints(COUNT);

/* ================= IMAGE TO SHAPE ================= */

function sampleImagePositions(img){
  const c = document.createElement("canvas");
  c.width = 256; c.height = 256;
  const ctx = c.getContext("2d");
  ctx.drawImage(img,0,0,256,256);
  const data = ctx.getImageData(0,0,256,256).data;

  let positions = [];

  for(let i=0;i<COUNT;i++){
    let found=false;
    while(!found){
      let x = Math.floor(Math.random()*256);
      let y = Math.floor(Math.random()*256);
      let idx = (y*256+x)*4;
      if(data[idx+3] > 120){ // alpha mask
        positions.push(
          (x/256 - 0.5)*2,
          -(y/256 - 0.5)*2,
          0
        );
        found=true;
      }
    }
  }
  return new Float32Array(positions);
}

/* ================= SHADER ================= */

const uniforms = {
  uProgress: { value:0 },
  uHover: { value:0 },
  uColor1: { value:new THREE.Color("#318bf7") },
  uColor2: { value:new THREE.Color("#bada4c") },
  uColor3: { value:new THREE.Color("#e35058") },
  uTime: { value:0 }
};

const material = new THREE.ShaderMaterial({
  uniforms,
  transparent:true,
  depthWrite:false,
  blending:THREE.AdditiveBlending,
  vertexShader:`
    attribute vec3 position2;
    uniform float uProgress;
    uniform float uHover;
    uniform float uTime;

    varying float vMix;

    void main(){
      vec3 pos = mix(position, position2, uProgress);

      float d = length(pos.xy);
      pos.z += sin(d*10.0 + uTime*2.0)*0.05*uHover;

      vMix = uProgress;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
      gl_PointSize = 2.5;
    }
  `,
  fragmentShader:`
    uniform vec3 uColor1;
    uniform vec3 uColor2;
    uniform vec3 uColor3;
    varying float vMix;

    void main(){
      float d = length(gl_PointCoord - 0.5);
      if(d>0.5) discard;

      vec3 col = mix(uColor1, uColor2, vMix);
      col = mix(col, uColor3, vMix*vMix);
      gl_FragColor = vec4(col,1.0);
    }
  `
});

/* ================= GEOMETRY ================= */

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(basePositions,3));
geometry.setAttribute('position2', new THREE.BufferAttribute(basePositions,3));

const points = new THREE.Points(geometry, material);
scene.add(points);

/* ================= LOAD TEXTURES ================= */

let shapes = [];

Promise.all(textures.map(src=>{
  return new Promise(res=>{
    let img = new Image();
    img.crossOrigin="anonymous";
    img.onload=()=>res(sampleImagePositions(img));
    img.src=src;
  });
})).then(arr=>{
  shapes = arr;
  geometry.setAttribute('position2', new THREE.BufferAttribute(shapes[0],3));
});

/* ================= INTERACTION ================= */

let currentShape = 0;

window.addEventListener("click",()=>{
  currentShape = (currentShape+1)%shapes.length;
  geometry.setAttribute('position2', new THREE.BufferAttribute(shapes[currentShape],3));
  gsap.to(uniforms.uProgress,{value:1,duration:1.5,ease:"power3.inOut",onComplete:()=>uniforms.uProgress.value=0});
});

window.addEventListener("mouseenter",()=>gsap.to(uniforms.uHover,{value:1,duration:0.6}));
window.addEventListener("mouseleave",()=>gsap.to(uniforms.uHover,{value:0,duration:0.6}));

window.addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

/* ================= LOOP ================= */

const clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  uniforms.uTime.value = clock.getElapsedTime();
  renderer.render(scene,camera);
}
animate();

</script>
</body>
</html>
